/* Generated by wayland-scanner 1.23.1 */

#ifndef RIVER_LAYOUT_V3_CLIENT_PROTOCOL_H
#define RIVER_LAYOUT_V3_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_river_layout_v3 The river_layout_v3 protocol
 * let clients propose view positions and dimensions
 *
 * @section page_desc_river_layout_v3 Description
 *
 * This protocol specifies a way for clients to propose arbitrary positions
 * and dimensions for a set of views on a specific output of a compositor
 * through the river_layout_v3 object.
 *
 * Layouts are a strictly linear list of views, the position and dimensions
 * of which are supplied by the client. Any complex underlying data structure
 * a client may use when generating the layout is lost in transmission. This
 * is an intentional limitation.
 *
 * Additionally, this protocol allows the compositor to deliver arbitrary
 * user-provided commands associated with a layout to clients. A client
 * may use these commands to implement runtime configuration/control, or
 * may ignore them entirely. How the user provides these commands to the
 * compositor is not specified by this protocol and left to compositor policy.
 *
 * Warning! The protocol described in this file is currently in the
 * testing phase. Backward compatible changes may be added together with
 * the corresponding interface version bump. Backward incompatible changes
 * can only be done by creating a new major version of the extension.
 *
 * @section page_ifaces_river_layout_v3 Interfaces
 * - @subpage page_iface_river_layout_manager_v3 - manage river layout objects
 * - @subpage page_iface_river_layout_v3 - receive and respond to layout demands
 * @section page_copyright_river_layout_v3 Copyright
 * <pre>
 *
 * Copyright 2020-2021 The River Developers
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * </pre>
 */
struct river_layout_manager_v3;
struct river_layout_v3;
struct wl_output;

#ifndef RIVER_LAYOUT_MANAGER_V3_INTERFACE
#define RIVER_LAYOUT_MANAGER_V3_INTERFACE
/**
 * @page page_iface_river_layout_manager_v3 river_layout_manager_v3
 * @section page_iface_river_layout_manager_v3_desc Description
 *
 * A global factory for river_layout_v3 objects.
 * @section page_iface_river_layout_manager_v3_api API
 * See @ref iface_river_layout_manager_v3.
 */
/**
 * @defgroup iface_river_layout_manager_v3 The river_layout_manager_v3 interface
 *
 * A global factory for river_layout_v3 objects.
 */
extern const struct wl_interface river_layout_manager_v3_interface;
#endif
#ifndef RIVER_LAYOUT_V3_INTERFACE
#define RIVER_LAYOUT_V3_INTERFACE
/**
 * @page page_iface_river_layout_v3 river_layout_v3
 * @section page_iface_river_layout_v3_desc Description
 *
 * This interface allows clients to receive layout demands from the
 * compositor for a specific output and subsequently propose positions and
 * dimensions of individual views.
 * @section page_iface_river_layout_v3_api API
 * See @ref iface_river_layout_v3.
 */
/**
 * @defgroup iface_river_layout_v3 The river_layout_v3 interface
 *
 * This interface allows clients to receive layout demands from the
 * compositor for a specific output and subsequently propose positions and
 * dimensions of individual views.
 */
extern const struct wl_interface river_layout_v3_interface;
#endif

#define RIVER_LAYOUT_MANAGER_V3_DESTROY 0
#define RIVER_LAYOUT_MANAGER_V3_GET_LAYOUT 1


/**
 * @ingroup iface_river_layout_manager_v3
 */
#define RIVER_LAYOUT_MANAGER_V3_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_layout_manager_v3
 */
#define RIVER_LAYOUT_MANAGER_V3_GET_LAYOUT_SINCE_VERSION 1

/** @ingroup iface_river_layout_manager_v3 */
static inline void
river_layout_manager_v3_set_user_data(struct river_layout_manager_v3 *river_layout_manager_v3, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_layout_manager_v3, user_data);
}

/** @ingroup iface_river_layout_manager_v3 */
static inline void *
river_layout_manager_v3_get_user_data(struct river_layout_manager_v3 *river_layout_manager_v3)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_layout_manager_v3);
}

static inline uint32_t
river_layout_manager_v3_get_version(struct river_layout_manager_v3 *river_layout_manager_v3)
{
	return wl_proxy_get_version((struct wl_proxy *) river_layout_manager_v3);
}

/**
 * @ingroup iface_river_layout_manager_v3
 *
 * This request indicates that the client will not use the
 * river_layout_manager object any more. Objects that have been created
 * through this instance are not affected.
 */
static inline void
river_layout_manager_v3_destroy(struct river_layout_manager_v3 *river_layout_manager_v3)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_layout_manager_v3,
			 RIVER_LAYOUT_MANAGER_V3_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_layout_manager_v3), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_layout_manager_v3
 *
 * This creates a new river_layout_v3 object for the given wl_output.
 *
 * All layout related communication is done through this interface.
 *
 * The namespace is used by the compositor to decide which river_layout_v3
 * object will receive layout demands for the output.
 *
 * The namespace is required to be be unique per-output. Furthermore,
 * two separate clients may not share a namespace on separate outputs. If
 * these conditions are not upheld, the the namespace_in_use event will
 * be sent directly after creation of the river_layout_v3 object.
 */
static inline struct river_layout_v3 *
river_layout_manager_v3_get_layout(struct river_layout_manager_v3 *river_layout_manager_v3, struct wl_output *output, const char *namespace)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) river_layout_manager_v3,
			 RIVER_LAYOUT_MANAGER_V3_GET_LAYOUT, &river_layout_v3_interface, wl_proxy_get_version((struct wl_proxy *) river_layout_manager_v3), 0, NULL, output, namespace);

	return (struct river_layout_v3 *) id;
}

#ifndef RIVER_LAYOUT_V3_ERROR_ENUM
#define RIVER_LAYOUT_V3_ERROR_ENUM
enum river_layout_v3_error {
	/**
	 * number of         proposed dimensions does not match number of views in layout
	 */
	RIVER_LAYOUT_V3_ERROR_COUNT_MISMATCH = 0,
	/**
	 * the layout demand with         the provided serial was already committed
	 */
	RIVER_LAYOUT_V3_ERROR_ALREADY_COMMITTED = 1,
};
#endif /* RIVER_LAYOUT_V3_ERROR_ENUM */

/**
 * @ingroup iface_river_layout_v3
 * @struct river_layout_v3_listener
 */
struct river_layout_v3_listener {
	/**
	 * the requested namespace is already in use
	 *
	 * After this event is sent, all requests aside from the destroy
	 * event will be ignored by the server. If the client wishes to try
	 * again with a different namespace they must create a new
	 * river_layout_v3 object.
	 */
	void (*namespace_in_use)(void *data,
				 struct river_layout_v3 *river_layout_v3);
	/**
	 * the compositor requires a layout
	 *
	 * The compositor sends this event to inform the client that it
	 * requires a layout for a set of views.
	 *
	 * The usable width and height indicate the space in which the
	 * client can safely position views without interfering with
	 * desktop widgets such as panels.
	 *
	 * The serial of this event is used to identify subsequent requests
	 * as belonging to this layout demand. Beware that the client might
	 * need to handle multiple layout demands at the same time.
	 *
	 * The server will ignore responses to all but the most recent
	 * layout demand. Thus, clients are only required to respond to the
	 * most recent layout_demand received. If a newer layout_demand is
	 * received before the client has finished responding to an old
	 * demand, the client should abort work on the old demand as any
	 * further work would be wasted.
	 * @param view_count number of views in the layout
	 * @param usable_width width of the usable area
	 * @param usable_height height of the usable area
	 * @param tags tags of the output, 32-bit bitfield
	 * @param serial serial of the layout demand
	 */
	void (*layout_demand)(void *data,
			      struct river_layout_v3 *river_layout_v3,
			      uint32_t view_count,
			      uint32_t usable_width,
			      uint32_t usable_height,
			      uint32_t tags,
			      uint32_t serial);
	/**
	 * a command sent by the user
	 *
	 * This event informs the client of a command sent to it by the
	 * user.
	 *
	 * The semantic meaning of the command is left for the client to
	 * decide. It is also free to ignore it entirely if it so chooses.
	 *
	 * A layout_demand will be sent after this event if the compositor
	 * is currently using this layout object to arrange the output.
	 *
	 * If version 2 or higher of the river_layout_v3 object is bound,
	 * the user_command_tags event is guaranteed to be sent directly
	 * before the user_command event.
	 */
	void (*user_command)(void *data,
			     struct river_layout_v3 *river_layout_v3,
			     const char *command);
	/**
	 * a command sent by the user
	 *
	 * If version 2 or higher of the river_layout_v3 object is bound,
	 * this event will be sent directly before every user_command
	 * event. This allows layout generators to be aware of the active
	 * tags when a user command is sent. This is necessary for
	 * generators wanting to keep settings on a per-tag basis.
	 * @param tags tags of the output, 32-bit bitfield
	 * @since 2
	 */
	void (*user_command_tags)(void *data,
				  struct river_layout_v3 *river_layout_v3,
				  uint32_t tags);
};

/**
 * @ingroup iface_river_layout_v3
 */
static inline int
river_layout_v3_add_listener(struct river_layout_v3 *river_layout_v3,
			     const struct river_layout_v3_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) river_layout_v3,
				     (void (**)(void)) listener, data);
}

#define RIVER_LAYOUT_V3_DESTROY 0
#define RIVER_LAYOUT_V3_PUSH_VIEW_DIMENSIONS 1
#define RIVER_LAYOUT_V3_COMMIT 2

/**
 * @ingroup iface_river_layout_v3
 */
#define RIVER_LAYOUT_V3_NAMESPACE_IN_USE_SINCE_VERSION 1
/**
 * @ingroup iface_river_layout_v3
 */
#define RIVER_LAYOUT_V3_LAYOUT_DEMAND_SINCE_VERSION 1
/**
 * @ingroup iface_river_layout_v3
 */
#define RIVER_LAYOUT_V3_USER_COMMAND_SINCE_VERSION 1
/**
 * @ingroup iface_river_layout_v3
 */
#define RIVER_LAYOUT_V3_USER_COMMAND_TAGS_SINCE_VERSION 2

/**
 * @ingroup iface_river_layout_v3
 */
#define RIVER_LAYOUT_V3_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_river_layout_v3
 */
#define RIVER_LAYOUT_V3_PUSH_VIEW_DIMENSIONS_SINCE_VERSION 1
/**
 * @ingroup iface_river_layout_v3
 */
#define RIVER_LAYOUT_V3_COMMIT_SINCE_VERSION 1

/** @ingroup iface_river_layout_v3 */
static inline void
river_layout_v3_set_user_data(struct river_layout_v3 *river_layout_v3, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) river_layout_v3, user_data);
}

/** @ingroup iface_river_layout_v3 */
static inline void *
river_layout_v3_get_user_data(struct river_layout_v3 *river_layout_v3)
{
	return wl_proxy_get_user_data((struct wl_proxy *) river_layout_v3);
}

static inline uint32_t
river_layout_v3_get_version(struct river_layout_v3 *river_layout_v3)
{
	return wl_proxy_get_version((struct wl_proxy *) river_layout_v3);
}

/**
 * @ingroup iface_river_layout_v3
 *
 * This request indicates that the client will not use the river_layout_v3
 * object any more.
 */
static inline void
river_layout_v3_destroy(struct river_layout_v3 *river_layout_v3)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_layout_v3,
			 RIVER_LAYOUT_V3_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) river_layout_v3), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_river_layout_v3
 *
 * This request proposes a size and position for a view in the layout demand
 * with matching serial.
 *
 * A client must send this request for every view that is part of the
 * layout demand. The number of views in the layout is given by the
 * view_count argument of the layout_demand event. Pushing too many or
 * too few view dimensions is a protocol error.
 *
 * The x and y coordinates are relative to the usable area of the output,
 * with (0,0) as the top left corner.
 */
static inline void
river_layout_v3_push_view_dimensions(struct river_layout_v3 *river_layout_v3, int32_t x, int32_t y, uint32_t width, uint32_t height, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_layout_v3,
			 RIVER_LAYOUT_V3_PUSH_VIEW_DIMENSIONS, NULL, wl_proxy_get_version((struct wl_proxy *) river_layout_v3), 0, x, y, width, height, serial);
}

/**
 * @ingroup iface_river_layout_v3
 *
 * This request indicates that the client is done pushing dimensions
 * and the compositor may apply the layout. This completes the layout
 * demand with matching serial, any other requests sent with the serial
 * are a protocol error.
 *
 * The layout_name argument is a user-facing name or short description
 * of the layout that is being committed. The compositor may for example
 * display this on a status bar, though what exactly is done with it is
 * left to the compositor's discretion.
 *
 * The compositor is free to use this proposed layout however it chooses,
 * including ignoring it.
 */
static inline void
river_layout_v3_commit(struct river_layout_v3 *river_layout_v3, const char *layout_name, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) river_layout_v3,
			 RIVER_LAYOUT_V3_COMMIT, NULL, wl_proxy_get_version((struct wl_proxy *) river_layout_v3), 0, layout_name, serial);
}

#ifdef  __cplusplus
}
#endif

#endif
